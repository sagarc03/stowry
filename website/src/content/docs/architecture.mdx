---
title: Architecture
description: Technical architecture and design decisions in Stowry.
---

# Architecture

This document describes Stowry's technical architecture and design decisions.

## Overview

Stowry follows a clean architecture with clear separation between:

- **Core domain logic** (root package)
- **Infrastructure adapters** (postgres, sqlite, filesystem, http packages)
- **CLI application** (cmd/stowry)

```
┌─────────────────────────────────────────────────────────┐
│                      CLI (cmd/stowry)                   │
│              Cobra commands, Viper config               │
└────────────────────────┬────────────────────────────────┘
                         │
┌────────────────────────▼────────────────────────────────┐
│                    HTTP Layer (http/)                   │
│           Chi router, handlers, middleware              │
└────────────────────────┬────────────────────────────────┘
                         │
┌────────────────────────▼────────────────────────────────┐
│                  Core Domain (stowry)                   │
│        StowryService, interfaces, business logic        │
└────────┬─────────────────────────────────┬──────────────┘
         │                                 │
┌────────▼────────┐               ┌────────▼────────┐
│   MetaDataRepo  │               │   FileStorage   │
│   (interface)   │               │   (interface)   │
└────────┬────────┘               └────────┬────────┘
         │                                 │
    ┌────┴────┐                       ┌────┴────┐
    ▼         ▼                       ▼         ▼
┌───────┐ ┌────────┐             ┌────────────────┐
│SQLite │ │Postgres│             │   Filesystem   │
└───────┘ └────────┘             └────────────────┘
```

## Core Package

The root `stowry` package contains:

### Interfaces

```go
// MetaDataRepo persists object metadata
type MetaDataRepo interface {
    Get(ctx context.Context, path string) (MetaData, error)
    Upsert(ctx context.Context, entry MetaData) error
    Delete(ctx context.Context, path string) error
    List(ctx context.Context, query ListQuery) (ListResult, error)
    ListPendingCleanup(ctx context.Context, query ListQuery) (ListResult, error)
    MarkCleanedUp(ctx context.Context, id uuid.UUID) error
}

// FileStorage handles file operations
type FileStorage interface {
    Get(ctx context.Context, path string) (io.ReadSeekCloser, error)
    Write(ctx context.Context, path string, content io.Reader) (FileInfo, error)
    Delete(ctx context.Context, path string) error
    List(ctx context.Context) ([]FileInfo, error)
}
```

### StowryService

The main service orchestrates metadata and storage operations:

```go
type StowryService struct {
    repo    MetaDataRepo
    storage FileStorage
    mode    ServerMode
}

func (s *StowryService) Create(ctx context.Context, obj CreateObject, content io.Reader) (MetaData, error)
func (s *StowryService) Get(ctx context.Context, path string) (MetaData, io.ReadSeekCloser, error)
func (s *StowryService) Delete(ctx context.Context, path string) error
func (s *StowryService) List(ctx context.Context, query ListQuery) (ListResult, error)
func (s *StowryService) Populate(ctx context.Context) error
func (s *StowryService) Tombstone(ctx context.Context, query ListQuery) (int, error)
```

### Domain Types

```go
type MetaData struct {
    ID            uuid.UUID
    Path          string
    ContentType   string
    Etag          string      // SHA256 hash
    FileSizeBytes int64
    CreatedAt     time.Time
    UpdatedAt     time.Time
    DeletedAt     *time.Time  // Soft delete timestamp
    CleanedUpAt   *time.Time  // Tombstone timestamp
}

type ServerMode string
const (
    ModeStore  ServerMode = "store"
    ModeStatic ServerMode = "static"
    ModeSPA    ServerMode = "spa"
)
```

## Database Backends

### SQLite (sqlite/)

- Uses `modernc.org/sqlite` (pure Go implementation)
- Single-file database, no external process
- Code-based migrations
- Ideal for development and small deployments

```go
repo, err := sqlite.NewRepo(db, tables)
```

### PostgreSQL (postgres/)

- Uses `pgx/v5` with connection pooling
- Code-based migrations
- Suitable for production and high concurrency

```go
repo, err := postgres.NewRepo(pool, tables)
```

### Schema

Both backends use the same schema:

```sql
CREATE TABLE stowry_metadata (
    id UUID PRIMARY KEY,
    path TEXT NOT NULL UNIQUE,
    content_type TEXT NOT NULL,
    etag TEXT NOT NULL,
    file_size_bytes BIGINT NOT NULL,
    created_at TIMESTAMP NOT NULL,
    updated_at TIMESTAMP NOT NULL,
    deleted_at TIMESTAMP,
    cleaned_up_at TIMESTAMP
);

CREATE INDEX idx_path ON stowry_metadata(path);
CREATE INDEX idx_deleted_at ON stowry_metadata(deleted_at);
CREATE INDEX idx_updated_at_path ON stowry_metadata(updated_at, path);
```

### Migrations

Migrations are code-based, not SQL files:

```go
// Run automatically on startup
err := sqlite.Migrate(ctx, db, tables)
err := postgres.Migrate(ctx, pool, tables)
```

## File Storage (filesystem/)

### Atomic Writes

Files are written atomically to prevent corruption:

1. Write content to temporary file
2. Calculate SHA256 hash
3. Rename temp file to final path

```go
func (s *FileStorage) Write(ctx context.Context, path string, content io.Reader) (FileInfo, error) {
    // 1. Create temp file
    temp, err := os.CreateTemp(dir, ".stowry-*")

    // 2. Write content, calculate hash
    hasher := sha256.New()
    writer := io.MultiWriter(temp, hasher)
    io.Copy(writer, content)

    // 3. Atomic rename
    os.Rename(temp.Name(), finalPath)
}
```

### Path Sandboxing

Uses `os.Root` to prevent path traversal attacks:

```go
root, err := os.OpenRoot(storagePath)
storage := filesystem.NewFileStorage(root)
```

### Content Type Detection

MIME types are detected from file extensions using Go's `mime` package.

## HTTP Layer (http/)

### Router

Uses Chi router with middleware:

```go
r := chi.NewRouter()
r.Use(PathValidationMiddleware)

r.Group(func(r chi.Router) {
    r.Use(AuthMiddleware(readConfig))
    r.Get("/", h.handleList)
    r.Get("/*", h.handleGet)
})

r.Group(func(r chi.Router) {
    r.Use(AuthMiddleware(writeConfig))
    r.Put("/*", h.handlePut)
    r.Delete("/*", h.handleDelete)
})
```

### Authentication Middleware

Supports two signing schemes:

1. **Stowry Native** - `X-Stowry-*` query parameters
2. **AWS Signature V4** - `X-Amz-*` query parameters

The middleware auto-detects which scheme to use based on query parameters.

## Two-Phase Deletion

Stowry uses soft deletion with cleanup:

### Phase 1: Soft Delete

```
DELETE /file.txt
```

1. Sets `deleted_at` timestamp
2. File remains in storage
3. Object excluded from listings

### Phase 2: Tombstone (Cleanup)

```bash
stowry cleanup
```

1. Queries objects where `deleted_at` is set but `cleaned_up_at` is not
2. Deletes physical file from storage
3. Sets `cleaned_up_at` timestamp
4. Metadata retained for audit trail

### Benefits

- Recoverable deletes (before cleanup runs)
- Consistent state between metadata and storage
- Audit trail of all operations
- Graceful handling of concurrent operations

## Error Handling

### Sentinel Errors

```go
var (
    ErrNotFound     = errors.New("not found")
    ErrInternal     = errors.New("internal error")
    ErrInvalidInput = errors.New("invalid input")
    ErrUnauthorized = errors.New("unauthorized")
)
```

### Error Wrapping

Errors are wrapped with context for debugging:

```go
return fmt.Errorf("create object %s: %w", path, err)
```

### HTTP Error Responses

```json
{
  "error": "not_found",
  "message": "Object not found"
}
```

## Pagination

Uses cursor-based pagination for consistent results:

### Cursor Format

```
Base64(updatedAt|path)
```

### Implementation

```go
type ListQuery struct {
    PathPrefix string
    Limit      int
    Cursor     string  // Encoded cursor
}

type ListResult struct {
    Items      []MetaData
    NextCursor string  // For next page
}
```

### Benefits

- Handles concurrent modifications gracefully
- No offset skipping issues
- Efficient for large datasets

## Configuration

### Precedence

1. Default values
2. Config file (config.yaml)
3. Environment variables (STOWRY_*)
4. Command-line flags

### Architecture Separation

Configuration logic stays in `cmd/stowry`:

```go
// cmd/stowry/root.go - Viper configuration
viper.SetDefault("server.port", 5708)
viper.SetEnvPrefix("STOWRY")
viper.AutomaticEnv()

// Core package - no config awareness
service, err := stowry.NewStowryService(repo, storage, mode)
```

## Testing

### Unit Tests

- Mock interfaces with `testify/mock`
- Black-box testing (`stowry_test` package)
- Table-driven tests

### Integration Tests

- PostgreSQL: `testcontainers-go` for real database
- SQLite: In-memory database (`:memory:`)

### Example Test Structure

```go
func TestStowryService_Create(t *testing.T) {
    tests := []struct {
        name    string
        setup   func(*SpyMetaDataRepo, *SpyFileStorage)
        obj     CreateObject
        content string
        wantErr error
    }{
        // Test cases...
    }

    for _, tt := range tests {
        t.Run(tt.name, func(t *testing.T) {
            // Setup, execute, assert
        })
    }
}
```

## Design Decisions

### Why Not S3 API Compatible?

Stowry intentionally doesn't implement the full S3 API:

1. **Simplicity** - Smaller codebase, easier to maintain
2. **Focused** - Only presigned URL authentication
3. **Flexibility** - Can evolve independently

### Why Presigned URLs?

1. **Security** - Credentials never exposed to clients
2. **Scalability** - No session state on server
3. **Compatibility** - Works with AWS SDK presigning

### Why Code-Based Migrations?

1. **Simplicity** - No separate migration files
2. **Reliability** - Migrations bundled with binary
3. **Testability** - Easy to test migration logic

### Why Two Metadata Backends?

1. **SQLite** - Zero-config, perfect for dev/small deployments
2. **PostgreSQL** - Production-ready, handles concurrency
